<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Змійка: DOOM ЕДИЦІЯ</title>
    <!-- === НОВИЙ ШРИФТ (ПІДКЛЮЧЕННЯ) === -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <!-- === === -->
    <style>
        /* === ОСНОВНИЙ СТИЛЬ === */
        body {
            background: radial-gradient(circle at center, #0d0d0d 0%, #000000 80%);
            color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: start;
            /* Шрифт 'Orbitron' тепер буде завантажено */
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        h1 {
            margin-top: 20px;
            color: #ff0000;
            font-size: 2.2rem;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
            animation: pulseTitle 2s infinite alternate;
        }

        @keyframes pulseTitle {
            from { text-shadow: 0 0 10px #ff0000; }
            to { text-shadow: 0 0 25px #ff3333; }
        }

        /* === ОБГОРТКА ГРИ === */
        .game-wrapper {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 30px;
            margin-top: 10px;
            /* Важливо для позиціонування .event-text */
            position: relative; 
        }

        /* === ЛЕГЕНДА === */
        .legend-container {
            background: rgba(20, 20, 20, 0.8);
            border: 2px solid #ff0000;
            border-radius: 10px;
            padding: 20px;
            width: 220px;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
            backdrop-filter: blur(6px);
            animation: floaty 4s ease-in-out infinite alternate;
        }

        @keyframes floaty {
            from { transform: translateY(0px); }
            to { transform: translateY(8px); }
        }

        .legend-container h3 {
            text-align: center;
            color: #00ffff;
            font-size: 1.4rem;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #00ffff;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .legend-color-box {
            width: 22px;
            height: 22px;
            border-radius: 5px;
            margin-right: 10px;
            border: 1px solid #555;
            transition: transform 0.3s;
        }

        .legend-color-box:hover {
            transform: scale(1.2);
        }

        .color-snake { background-color: #dc143c; box-shadow: 0 0 10px #dc143c; }
        .color-fruit { background-color: #00ffff; box-shadow: 0 0 10px #00ffff; }
        .color-obstacle { background-color: #8a2be2; box-shadow: 0 0 10px #8a2be2; }
        .color-slow { background-color: #3498db; box-shadow: 0 0 10px #3498db; }
        .color-ghost { background-color: #ecf0f1; box-shadow: 0 0 10px #ecf0f1; }

        /* === CANVAS === */
        canvas {
            /* Статичний фон канви, зірки малюються поверх */
            background: #000; 
            border: 3px solid #ff0000;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.4);
            transition: all 0.2s ease-in-out;
        }

        canvas:hover {
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.6);
            transform: scale(1.02);
        }

        /* === КНОПКИ === */
        .controls-container {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 25px;
        }

        .action-button {
            /* Шрифт Orbitron застосується */
            font-family: 'Orbitron', 'Segoe UI', sans-serif; 
            font-size: 1.2rem;
            font-weight: bold;
            color: #fff;
            background: linear-gradient(135deg, #ff0000, #800000);
            border: none;
            height: 50px;
            padding: 0 30px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.25s ease;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
        }

        .action-button:hover {
            transform: scale(1.1);
            background: linear-gradient(135deg, #ff3333, #990000);
            box-shadow: 0 0 25px rgba(255, 0, 0, 0.8);
        }

        .action-button:active {
            transform: scale(0.95);
            background: linear-gradient(135deg, #b30000, #4d0000);
        }

        /* === ПЛАВНА ДИНАМІКА ТЕКСТУ === */
        .event-text {
            position: absolute;
            /* Позиціонуємо відносно .game-wrapper */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: yellow;
            font-weight: bold;
            font-size: 2.5rem; /* Зробив трохи більшим */
            text-shadow: 0 0 15px yellow;
            animation: floatUp 2s ease-out forwards;
            pointer-events: none; /* Щоб не заважав клікати */
            z-index: 100;
        }

        @keyframes floatUp {
            0% { opacity: 0; transform: translate(-50%, -30%); }
            30% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -100%); }
        }

        /* === МОБІЛЬНА АДАПТАЦІЯ === */
        @media (max-width: 700px) {
            body {
                height: auto;
                overflow: auto;
            }
            .game-wrapper {
                flex-direction: column-reverse;
                align-items: center;
            }

            .legend-container {
                width: 90%;
                max-width: 400px; /* Обмеження ширини */
            }

            canvas {
                width: 90vw;
                height: 90vw;
            }
        }
    </style>
</head>
<body>
    <h1>ЗМІЙКА: DOOM ЕДИЦІЯ ⚡</h1>

    <div class="game-wrapper" id="gameWrapper">
        <div class="legend-container">
            <h3>ЛЕГЕНДА</h3>
            <div class="legend-item">
                <div class="legend-color-box color-snake"></div>
                <span>Змійка</span>
            </div>
            <div class="legend-item">
                <div class="legend-color-box color-fruit"></div>
                <span>Фрукт (+1)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color-box color-obstacle"></div>
                <span>Перешкода ☠️</span>
            </div>
            <div class="legend-item">
                <div class="legend-color-box color-slow"></div>
                <span>Уповільнення (6с)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color-box color-ghost"></div>
                <span>Привид (8с)</span>
            </div>
        </div>

        <canvas id="gameCanvas" width="400" height="400"></canvas>
    </div>

    <div class="controls-container">
        <button id="startPauseButton" class="action-button">Старт</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameWrapper = document.getElementById('gameWrapper');

        const gridSize = 20;
        const gridWidth = canvas.width / gridSize;
        const gridHeight = canvas.height / gridSize;

        let snake = [{ x: 10, y: 10 }];
        let fruit = { x: 15, y: 15 };
        let velocity = { x: 0, y: 0 };
        let score = 0;
        let highScore = 0;
        let changingDirection = false;
        let pauseGame = true;
        let gameRunning = false;
        
        let baseGameSpeed = 100;
        let gameSpeed = 100;
        let gameInterval;

        let currentLevel = 0; 
        let obstacles = []; 
        
        // Видалено: eventMessage та eventMessageTimer (тепер це HTML)

        let potion = null;
        let potionSpawnTimer = 10000;
        let activeBuff = { type: 'none', timer: 0 };

        // === НОВІ ЗМІННІ ДЛЯ ДИНАМІКИ ===
        let particles = [];
        let stars = [];
        // ==================================

        const startPauseButton = document.getElementById('startPauseButton');
        
        startPauseButton.addEventListener('click', () => {
            if (!gameRunning) {
                gameRunning = true;
                pauseGame = false;
                
                if (velocity.x === 0 && velocity.y === 0) {
                    velocity = { x: 1, y: 0 }; 
                }
                
                startGameInterval();
                startPauseButton.textContent = 'Пауза';
            } else {
                pauseGame = !pauseGame;
                startPauseButton.textContent = pauseGame ? 'Продовжити' : 'Пауза';
            }
        });

        function startGameInterval() {
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(gameLoop, gameSpeed); 
        }

        // === НОВА ФУНКЦІЯ: ОНОВЛЕННЯ ЧАСТИНОК ===
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= gameSpeed;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        // ======================================

        function gameLoop() {
            if (pauseGame) {
                drawGame(); 
                return;
            }

            // Оновлюємо таймери
            if (potionSpawnTimer > 0) potionSpawnTimer -= gameSpeed;
            if (activeBuff.timer > 0) activeBuff.timer -= gameSpeed;

            // === НОВЕ: Оновлюємо логіку частинок ===
            updateParticles();
            // ======================================

            if (activeBuff.timer <= 0 && activeBuff.type !== 'none') {
                deactivateBuff();
            }

            if (potion === null && potionSpawnTimer <= 0) {
                placePotion();
            }

            changingDirection = false; 
            moveSnake(); 

            if (isGameOver()) { 
                clearInterval(gameInterval);
                gameRunning = false;
                pauseGame = true;
                startPauseButton.textContent = 'Старт';

                if (score > highScore) {
                    highScore = score;
                    saveHighScore();
                }

                // Скидання гри
                snake = [{ x: 10, y: 10 }];
                velocity = { x: 0, y: 0 }; 
                score = 0;
                baseGameSpeed = 100; 
                gameSpeed = 100;
                currentLevel = 0;
                obstacles = []; 
                potion = null;
                potionSpawnTimer = 10000;
                activeBuff = { type: 'none', timer: 0 };
                particles = []; // Очищуємо частинки

                placeFruit();
                drawGame(); 
                return;
            }

            if (didEatPotion()) {
                activateBuff(potion.type);
                potion = null;
                potionSpawnTimer = 15000;
            }

            if (didEatFruit()) {
                score++;
                // === НОВЕ: Запускаємо частинки! ===
                triggerParticles(fruit.x * gridSize + gridSize / 2, fruit.y * gridSize + gridSize / 2, '#00FFFF', 20);
                // =================================
                placeFruit();
                checkGameEvents(); 
            } else {
                snake.pop(); 
            }

            drawGame(); 
        }

        function moveSnake() {
            let newX = snake[0].x + velocity.x;
            let newY = snake[0].y + velocity.y;

            if (newX < 0) newX = gridWidth - 1;
            else if (newX >= gridWidth) newX = 0;
            if (newY < 0) newY = gridHeight - 1;
            else if (newY >= gridHeight) newY = 0;

            const head = { x: newX, y: newY };
            snake.unshift(head); 
        }

        function didEatFruit() {
            return snake[0].x === fruit.x && snake[0].y === fruit.y;
        }

        function didEatPotion() {
            return potion && snake[0].x === potion.x && snake[0].y === potion.y;
        }

        function isCellFree(x, y) {
            for (let part of snake) {
                if (part.x === x && part.y === y) return false;
            }
            for (let ob of obstacles) {
                if (ob.x === x && ob.y === y) return false;
            }
            if (fruit.x === x && fruit.y === y) return false;
            if (potion && potion.x === x && potion.y === y) return false;
            
            return true;
        }

        function placeFruit() {
            let placed = false;
            while (!placed) {
                let testX = Math.floor(Math.random() * gridWidth);
                let testY = Math.floor(Math.random() * gridHeight);
                if (isCellFree(testX, testY)) {
                    fruit.x = testX;
                    fruit.y = testY;
                    placed = true;
                }
            }
        }

        function placePotion() {
            if (Math.random() < 0.5) {
                potionSpawnTimer = 10000;
                return;
            }

            let placed = false;
            while (!placed) {
                let testX = Math.floor(Math.random() * gridWidth);
                let testY = Math.floor(Math.random() * gridHeight);
                
                let nearHead = (Math.abs(testX - snake[0].x) <= 3 && Math.abs(testY - snake[0].y) <= 3);
                
                if (isCellFree(testX, testY) && !nearHead) {
                    let type = (Math.random() < 0.7) ? 'slow' : 'ghost';
                    potion = { x: testX, y: testY, type: type };
                    placed = true;
                }
            }
            potionSpawnTimer = 15000;
        }

        function activateBuff(type) {
            if (type === 'slow') {
                activeBuff.type = 'slow';
                activeBuff.timer = 6000;
                gameSpeed = baseGameSpeed + 50;
                startGameInterval();
                showEventMessage("SLOW-MO (6s)!");
            } else if (type === 'ghost') {
                activeBuff.type = 'ghost';
                activeBuff.timer = 8000;
                showEventMessage("GHOST (8s)!");
            }
        }

        function deactivateBuff() {
            let type = activeBuff.type;
            activeBuff.type = 'none';
            activeBuff.timer = 0;

            if (type === 'slow') {
                gameSpeed = baseGameSpeed;
                startGameInterval();
                showEventMessage("Speed normal");
            } else if (type === 'ghost') {
                showEventMessage("Ghost Faded");
            }
        }

        function generateObstacles(count) {
            for (let i = 0; i < count; i++) {
                let placed = false;
                while (!placed) {
                    let obX = Math.floor(Math.random() * gridWidth);
                    let obY = Math.floor(Math.random() * gridHeight);
                    let nearHead = (Math.abs(obX - snake[0].x) <= 2 && Math.abs(obY - snake[0].y) <= 2);

                    if (isCellFree(obX, obY) && !nearHead) {
                        obstacles.push({ x: obX, y: obY });
                        placed = true;
                    }
                }
            }
        }

        // === ОНОВЛЕНА ФУНКЦІЯ: showEventMessage ===
        // Тепер створює HTML елемент замість малювання на канві
        function showEventMessage(msg) {
            const eventEl = document.createElement('div');
            eventEl.className = 'event-text';
            eventEl.textContent = msg;
            
            // Додаємо до gameWrapper, щоб він був поверх канви
            gameWrapper.appendChild(eventEl);
            
            // Видаляємо елемент після анімації (2000ms)
            setTimeout(() => {
                if (eventEl.parentElement) {
                    eventEl.parentElement.removeChild(eventEl);
                }
            }, 2000);
        }
        // ========================================

        function checkGameEvents() {
            let speedChanged = false;

            if (score >= 50 && currentLevel === 2) {
                baseGameSpeed = 60; 
                currentLevel = 3;
                generateObstacles(5);
                showEventMessage("MAXIMUM DOOM!");
                speedChanged = true;
            } else if (score >= 25 && currentLevel === 1) {
                currentLevel = 2;
                generateObstacles(5); 
                showEventMessage("OBSTACLES!");
            } else if (score >= 10 && currentLevel === 0) {
                baseGameSpeed = 80;
                currentLevel = 1;
                showEventMessage("SPEED UP!");
                speedChanged = true;
            }

            if (speedChanged && activeBuff.type !== 'slow') {
                gameSpeed = baseGameSpeed;
                startGameInterval();
            }
        }

        function isGameOver() {
            const head = snake[0];

            if (activeBuff.type === 'ghost') {
                return false;
            }

            for (let i = 1; i < snake.length; i++) {
                if (snake[i].x === head.x && snake[i].y === head.y) {
                    return true;
                }
            }

            for (let ob of obstacles) {
                if (ob.x === head.x && ob.y === head.y) {
                    return true;
                }
            }

            return false;
        }

        // === НОВІ ФУНКЦІЇ ДЛЯ ДИНАМІКИ ===
        function initStars() {
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5,
                    opacity: Math.random() * 0.5 + 0.2 // тьмяні
                });
            }
        }

        function drawStars() {
            for (let star of stars) {
                // Оновлюємо позицію для "мерехтіння"
                star.opacity += (Math.random() - 0.5) * 0.1;
                if (star.opacity > 0.7) star.opacity = 0.7;
                if (star.opacity < 0.1) star.opacity = 0.1;

                ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function triggerParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4, // швидкість по x
                    vy: (Math.random() - 0.5) * 4, // швидкість по y
                    color: color,
                    life: Math.random() * 500 + 300 // час життя
                });
            }
        }

        function drawParticles() {
            for (let p of particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 500; // згасання
                ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                ctx.globalAlpha = 1.0;
            }
        }
        // ==================================

        // === ОНОВЛЕНА ФУНКЦІЯ: drawGame ===
        function drawGame() {
            // 1. Малюємо фон
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 2. Малюємо динамічні зірки
            drawStars();

            // 3. Малюємо змійку (НОВИЙ СТИЛЬ)
            let head = snake[0];
            let headColor = (activeBuff.type === 'ghost') ? 'rgba(220, 20, 60, 0.5)' : '#DC143C';
            let bodyColor = headColor;
            
            // Малюємо тіло
            ctx.fillStyle = bodyColor;
            for (let i = 1; i < snake.length; i++) {
                let part = snake[i];
                ctx.fillRect(part.x * gridSize, part.y * gridSize, gridSize - 1, gridSize - 1);
                // Обводка для тіла
                if (activeBuff.type !== 'ghost') {
                    ctx.strokeStyle = '#8B0000'; // Темно-червона
                    ctx.lineWidth = 2;
                    ctx.strokeRect(part.x * gridSize, part.y * gridSize, gridSize - 1, gridSize - 1);
                }
            }

            // Малюємо голову
            ctx.fillStyle = headColor;
            ctx.fillRect(head.x * gridSize, head.y * gridSize, gridSize - 1, gridSize - 1);
            // Пульсуюче "ядро" голови
            if (activeBuff.type !== 'ghost') {
                let pulse = Math.sin(Date.now() / 150) * 0.2 + 0.8; // 0.6 to 1.0
                ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`; // Яскраво-червоне
                ctx.fillRect(head.x * gridSize + 3, head.y * gridSize + 3, gridSize - 7, gridSize - 7);
            }
            
            // Малюємо очі (поверх ядра)
            ctx.fillStyle = 'white';
            let eyeSize = gridSize / 5;
            let eyeOffset = gridSize / 4;
            // (Логіка очей залишається та ж сама)
            if (velocity.x === 1) { // Вправо
                ctx.fillRect(head.x * gridSize + eyeOffset, head.y * gridSize + eyeOffset, eyeSize, eyeSize);
                ctx.fillRect(head.x * gridSize + eyeOffset, head.y * gridSize + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
            } else if (velocity.x === -1) { // Вліво
                ctx.fillRect(head.x * gridSize + gridSize - eyeOffset - eyeSize, head.y * gridSize + eyeOffset, eyeSize, eyeSize);
                ctx.fillRect(head.x * gridSize + gridSize - eyeOffset - eyeSize, head.y * gridSize + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
            } else if (velocity.y === 1) { // Вниз
                ctx.fillRect(head.x * gridSize + eyeOffset, head.y * gridSize + eyeOffset, eyeSize, eyeSize);
                ctx.fillRect(head.x * gridSize + gridSize - eyeOffset - eyeSize, head.y * gridSize + eyeOffset, eyeSize, eyeSize);
            } else if (velocity.y === -1 || (velocity.x === 0 && velocity.y === 0)) { // Вгору (або стоїть на місці)
                ctx.fillRect(head.x * gridSize + eyeOffset, head.y * gridSize + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
                ctx.fillRect(head.x * gridSize + gridSize - eyeOffset - eyeSize, head.y * gridSize + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
            }


            // 4. Малюємо фрукт (НОВИЙ СТИЛЬ - ПУЛЬСАЦІЯ)
            ctx.shadowColor = '#00FFFF'; // Колір сяйва
            // Анімоване сяйво
            ctx.shadowBlur = 10 + Math.sin(Date.now() / 200) * 5; 
            ctx.fillStyle = '#00FFFF';
            ctx.fillRect(fruit.x * gridSize, fruit.y * gridSize, gridSize - 1, gridSize - 1);
            // Скидаємо тінь
            ctx.shadowBlur = 0;


            // 5. Малюємо зілля
            if (potion) {
                if (potion.type === 'slow') {
                    ctx.fillStyle = '#3498db';
                    ctx.shadowColor = '#3498db';
                } else if (potion.type === 'ghost') {
                    ctx.fillStyle = '#ecf0f1';
                    ctx.shadowColor = '#ecf0f1';
                }
                ctx.shadowBlur = 10;
                ctx.fillRect(potion.x * gridSize, potion.y * gridSize, gridSize - 1, gridSize - 1);
                ctx.shadowBlur = 0;
            }

            // 6. Малюємо перешкоди
            ctx.fillStyle = '#8A2BE2';
            ctx.shadowColor = '#8A2BE2';
            ctx.shadowBlur = 10;
            for (let ob of obstacles) {
                ctx.fillRect(ob.x * gridSize, ob.y * gridSize, gridSize - 1, gridSize - 1);
            }
            ctx.shadowBlur = 0;
            
            // 7. Малюємо частинки (поверх усього)
            drawParticles();

            // 8. Малюємо UI (Рахунок, таймери)
            ctx.fillStyle = 'white';
            ctx.font = "18px 'Orbitron', sans-serif"; // Використовуємо новий шрифт
            ctx.textAlign = 'left';
            ctx.fillText('Рахунок: ' + score, 10, 25);
            ctx.textAlign = 'right';
            ctx.fillText('Рекорд: ' + highScore, canvas.width - 10, 25);
            
            if (activeBuff.timer > 0) {
                ctx.textAlign = 'center';
                ctx.font = "bold 20px 'Orbitron', sans-serif";
                let timerText = (activeBuff.timer / 1000).toFixed(1) + "s";
                
                if (activeBuff.type === 'ghost') {
                    ctx.fillStyle = '#ecf0f1';
                    ctx.fillText('GHOST: ' + timerText, canvas.width / 2, 25);
                } else if (activeBuff.type === 'slow') {
                    ctx.fillStyle = '#3498db';
                    ctx.fillText('SLOW: ' + timerText, canvas.width / 2, 25);
                }
            }

            ctx.textAlign = 'center'; // Скидання

            // 9. Малюємо екран паузи
            if (pauseGame && gameRunning) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = "bold 40px 'Orbitron', sans-serif";
                ctx.fillText('ПАУЗА', canvas.width / 2, canvas.height / 2);
            }

            // Блок малювання 'eventMessage' видалено,
            // оскільки тепер він обробляється через HTML
        }
        // ==================================

        document.addEventListener('keydown', changeDirection);
        function changeDirection(event) {
            const keyPressed = event.key;

            if (keyPressed === ' ' && gameRunning) {
                event.preventDefault(); 
                pauseGame = !pauseGame;
                startPauseButton.textContent = pauseGame ? 'Продовжити' : 'Пауза';
                return;
            }

            if (changingDirection || pauseGame || !gameRunning) return;

            const goingUp = velocity.y === -1;
            const goingDown = velocity.y === 1;
            const goingRight = velocity.x === 1;
            const goingLeft = velocity.x === -1;

            switch (keyPressed.toLowerCase()) {
                case 'arrowup':
                case 'w':
                    if (!goingDown) velocity = { x: 0, y: -1 };
                    break;
                case 'arrowdown':
                case 's':
                    if (!goingUp) velocity = { x: 0, y: 1 };
                    break;
                case 'arrowleft':
                case 'a':
                    if (!goingRight) velocity = { x: -1, y: 0 };
                    break;
                case 'arrowright':
                case 'd':
                    if (!goingLeft) velocity = { x: 1, y: 0 };
                    break;
            }
            changingDirection = true; 
        }

        function saveHighScore() {
            try {
                localStorage.setItem('snakeHighScore', highScore);
            } catch (e) {
                console.error("Не вдалося зберегти рекорд:", e);
            }
        }

        function loadHighScore() {
            try {
                const saved = localStorage.getItem('snakeHighScore');
                if (saved) {
                    highScore = parseInt(saved);
                }
            } catch (e) {
                console.error("Не вдалося завантажити рекорд:", e);
            }
        }

        // === ІНІЦІАЛІЗАЦІЯ ===
        initStars(); // Створюємо зірки
        loadHighScore();
        placeFruit();
        drawGame(); 
    </script>
</body>
</html>
